<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>点线面 · 交互草图</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #1a1a1a;
      font-family: system-ui, sans-serif;
    }
    main {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      padding: 1rem;
    }
    #canvas-wrap {
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }
    .hint {
      color: rgba(255,255,255,0.6);
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <main>
    <div id="canvas-wrap"></div>
    <p class="hint">移动鼠标与画面中的点、线、形互动</p>
  </main>

  <script>
    let shapes = [];
    let linesArr = [];
    let dots = [];
    let palette;

    function setup() {
      let canvas = createCanvas(1080, 500);
      canvas.parent('canvas-wrap');
      rectMode(CENTER);
      colorMode(HSB, 360, 100, 100, 100);

      palette = [
        color(30, 80, 90),
        color(200, 60, 90),
        color(50, 80, 90),
        color(330, 80, 90),
        color(120, 60, 80)
      ];

      for (let i = 0; i < 1500; i++) {
        dots.push(new SoftDot());
      }

      for (let i = 0; i < 30; i++) {
        linesArr.push(new LooseLine());
      }

      for (let i = 0; i < 90; i++) {
        shapes.push(new RandomGeometry());
      }
    }

    function draw() {
      background(0, 0, 95);

      for (let d of dots) {
        d.update();
        d.display();
      }

      for (let l of linesArr) {
        l.update();
        l.display();
      }

      for (let s of shapes) {
        s.update();
        s.display();
      }
    }

    // ===============================
    // Classes
    // ===============================

    class RandomGeometry {
      constructor() {
        this.x = random(-150, width + 150);
        this.y = random(-150, height + 150);
        this.size = random(15, 75);
        this.c = random(palette);
        this.type = int(random(5));
        this.isFilled = random() < 0.6;
        this.rot = radians(random(-40, 40));

        this.baseVx = random(-0.2, 0.2);
        this.baseVy = random(-0.2, 0.2);
        this.vx = this.baseVx;
        this.vy = this.baseVy;
        this.vRot = random(-0.01, 0.01);

        this.noiseOffset = random(1000);
      }

      update() {
        let d = dist(mouseX, mouseY, this.x, this.y);
        let interactionRadius = 150;

        if (d < interactionRadius && mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {
          let force = map(d, 0, interactionRadius, 5, 0);
          let angle = atan2(this.y - mouseY, this.x - mouseX);

          this.vx += cos(angle) * force * 0.1;
          this.vy += sin(angle) * force * 0.1;
        }

        this.vx = lerp(this.vx, this.baseVx, 0.05);
        this.vy = lerp(this.vy, this.baseVy, 0.05);

        this.x += this.vx;
        this.y += this.vy;
        this.rot += this.vRot;

        if (this.x > width + 200) this.x = -200;
        if (this.x < -200) this.x = width + 200;
        if (this.y > height + 200) this.y = -200;
        if (this.y < -200) this.y = height + 200;
      }

      display() {
        let flicker = noise(frameCount * 0.02 + this.noiseOffset);
        let maxAlpha = this.isFilled ? 70 : 85;
        let currentAlpha = maxAlpha * (0.3 + flicker * 0.7);

        push();
        translate(this.x, this.y);
        rotate(this.rot);

        if (this.isFilled) {
          noStroke();
          fill(hue(this.c), saturation(this.c), brightness(this.c), currentAlpha);
        } else {
          noFill();
          stroke(hue(this.c), saturation(this.c), brightness(this.c), currentAlpha);
          strokeWeight(2);
        }

        drawGeometry(this.type, this.size);
        pop();
      }
    }

    class LooseLine {
      constructor() {
        this.x1 = random(-150, width + 150);
        this.y1 = random(-150, height + 150);
        this.dx = random(-300, 300);
        this.dy = random(-80, 80);
        this.c = random(palette);

        this.baseVx = random(-0.5, 0.5);
        this.baseVy = random(-0.2, 0.2);
        this.vx = this.baseVx;
        this.vy = this.baseVy;
        this.noiseOffset = random(1000);
      }

      update() {
        let centerX = this.x1 + this.dx / 2;
        let centerY = this.y1 + this.dy / 2;
        let d = dist(mouseX, mouseY, centerX, centerY);
        let interactionRadius = 200;

        if (d < interactionRadius && mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {
          let force = map(d, 0, interactionRadius, 4, 0);
          let angle = atan2(centerY - mouseY, centerX - mouseX);
          this.vx += cos(angle) * force * 0.1;
          this.vy += sin(angle) * force * 0.1;
        }

        this.vx = lerp(this.vx, this.baseVx, 0.05);
        this.vy = lerp(this.vy, this.baseVy, 0.05);

        this.x1 += this.vx;
        this.y1 += this.vy;

        if (this.x1 > width + 300) this.x1 = -300;
        if (this.x1 < -300) this.x1 = width + 300;
        if (this.y1 > height + 150) this.y1 = -150;
        if (this.y1 < -150) this.y1 = height + 150;
      }

      display() {
        let flicker = noise(frameCount * 0.03 + this.noiseOffset);
        let currentAlpha = 50 * (0.2 + flicker * 1.2);

        stroke(hue(this.c), saturation(this.c), brightness(this.c), currentAlpha);
        strokeWeight(2);
        line(this.x1, this.y1, this.x1 + this.dx, this.y1 + this.dy);
      }
    }

    class SoftDot {
      constructor() {
        this.x = random(-50, width + 50);
        this.y = random(-50, height + 50);
        this.size = random(2, 5);
        this.c = random(palette);
        this.baseAlpha = random(10, 30);

        this.baseVx = random(-0.2, 0.2);
        this.baseVy = random(-0.2, 0.2);
        this.vx = this.baseVx;
        this.vy = this.baseVy;
        this.noiseOffset = random(1000);
      }

      update() {
        let d = dist(mouseX, mouseY, this.x, this.y);
        let interactionRadius = 100;

        if (d < interactionRadius && mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {
          let force = map(d, 0, interactionRadius, 3, 0);
          let angle = atan2(this.y - mouseY, this.x - mouseX);
          this.vx += cos(angle) * force * 0.15;
          this.vy += sin(angle) * force * 0.15;
        }

        this.vx = lerp(this.vx, this.baseVx, 0.1);
        this.vy = lerp(this.vy, this.baseVy, 0.1);

        this.x += this.vx;
        this.y += this.vy;

        if (this.x > width + 50) this.x = -50;
        if (this.x < -50) this.x = width + 50;
        if (this.y > height + 50) this.y = -50;
        if (this.y < -50) this.y = height + 50;
      }

      display() {
        let flicker = noise(frameCount * 0.05 + this.noiseOffset);
        let currentAlpha = this.baseAlpha * (0.1 + flicker * 1.5);

        noStroke();
        fill(hue(this.c), saturation(this.c), brightness(this.c), currentAlpha);
        circle(this.x, this.y, this.size);
      }
    }

    // ===============================
    // Shape functions
    // ===============================
    function drawGeometry(type, s) {
      if (type === 0) drawTriangle(s);
      if (type === 1) drawPentagon(s);
      if (type === 2) drawHexagon(s);
      if (type === 3) ellipse(0, 0, s, s);
      if (type === 4) drawTrapezoid(s);
    }

    function drawTriangle(s) {
      beginShape();
      vertex(-s / 2, s / 2);
      vertex(0, -s / 2);
      vertex(s / 2, s / 2);
      endShape(CLOSE);
    }

    function drawPentagon(s) {
      polygon(5, s);
    }

    function drawHexagon(s) {
      polygon(6, s);
    }

    function drawTrapezoid(s) {
      beginShape();
      vertex(-s * 0.5, s * 0.4);
      vertex(s * 0.5, s * 0.4);
      vertex(s * 0.3, -s * 0.4);
      vertex(-s * 0.3, -s * 0.4);
      endShape(CLOSE);
    }

    function polygon(n, s) {
      beginShape();
      for (let i = 0; i < n; i++) {
        let angle = TWO_PI / n * i;
        let x = cos(angle) * s / 2;
        let y = sin(angle) * s / 2;
        vertex(x, y);
      }
      endShape(CLOSE);
    }
  </script>
</body>
</html>
